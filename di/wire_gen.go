// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package di

import (
	"path/filepath"
	"testing"

	"github.com/boreq/errors"
	badger2 "github.com/dgraph-io/badger/v3"
	"github.com/planetary-social/scuttlego/fixtures"
	"github.com/planetary-social/scuttlego/logging"
	migrations2 "github.com/planetary-social/scuttlego/migrations"
	"github.com/planetary-social/scuttlego/service/adapters"
	"github.com/planetary-social/scuttlego/service/adapters/badger"
	"github.com/planetary-social/scuttlego/service/adapters/badger/notx"
	ebt2 "github.com/planetary-social/scuttlego/service/adapters/ebt"
	"github.com/planetary-social/scuttlego/service/adapters/invites"
	"github.com/planetary-social/scuttlego/service/adapters/migrations"
	"github.com/planetary-social/scuttlego/service/adapters/mocks"
	"github.com/planetary-social/scuttlego/service/adapters/pubsub"
	"github.com/planetary-social/scuttlego/service/app"
	"github.com/planetary-social/scuttlego/service/app/commands"
	"github.com/planetary-social/scuttlego/service/app/queries"
	"github.com/planetary-social/scuttlego/service/domain"
	"github.com/planetary-social/scuttlego/service/domain/blobs"
	"github.com/planetary-social/scuttlego/service/domain/blobs/replication"
	"github.com/planetary-social/scuttlego/service/domain/feeds/content"
	"github.com/planetary-social/scuttlego/service/domain/feeds/content/transport"
	"github.com/planetary-social/scuttlego/service/domain/feeds/formats"
	"github.com/planetary-social/scuttlego/service/domain/identity"
	invites2 "github.com/planetary-social/scuttlego/service/domain/invites"
	mocks2 "github.com/planetary-social/scuttlego/service/domain/mocks"
	"github.com/planetary-social/scuttlego/service/domain/network"
	"github.com/planetary-social/scuttlego/service/domain/network/local"
	replication2 "github.com/planetary-social/scuttlego/service/domain/replication"
	"github.com/planetary-social/scuttlego/service/domain/replication/ebt"
	"github.com/planetary-social/scuttlego/service/domain/replication/gossip"
	"github.com/planetary-social/scuttlego/service/domain/rooms"
	"github.com/planetary-social/scuttlego/service/domain/rooms/tunnel"
	transport2 "github.com/planetary-social/scuttlego/service/domain/transport"
	"github.com/planetary-social/scuttlego/service/domain/transport/boxstream"
	"github.com/planetary-social/scuttlego/service/domain/transport/rpc"
	"github.com/planetary-social/scuttlego/service/domain/transport/rpc/mux"
	network2 "github.com/planetary-social/scuttlego/service/ports/network"
	pubsub2 "github.com/planetary-social/scuttlego/service/ports/pubsub"
	rpc2 "github.com/planetary-social/scuttlego/service/ports/rpc"
)

// Injectors from wire.go:

func BuildBadgerNoTxTestAdapters(t *testing.T) BadgerNoTxTestAdapters {
	db := fixtures.Badger(t)
	testTxAdaptersFactory := noTxTestTxAdaptersFactory()
	banListHasherMock := mocks.NewBanListHasherMock()
	currentTimeProviderMock := mocks.NewCurrentTimeProviderMock()
	rawMessageIdentifierMock := mocks.NewRawMessageIdentifierMock()
	public := fixtures.SomePublicIdentity()
	testAdaptersDependencies := badger.TestAdaptersDependencies{
		BanListHasher:        banListHasherMock,
		CurrentTimeProvider:  currentTimeProviderMock,
		RawMessageIdentifier: rawMessageIdentifierMock,
		LocalIdentity:        public,
	}
	testTxAdaptersFactoryTransactionProvider := notx.NewTestTxAdaptersFactoryTransactionProvider(db, testTxAdaptersFactory, testAdaptersDependencies)
	devNullLogger := logging.NewDevNullLogger()
	noTxBlobWantListRepository := notx.NewNoTxBlobWantListRepository(testTxAdaptersFactoryTransactionProvider, devNullLogger)
	testAdapters := notx.TestAdapters{
		NoTxBlobWantListRepository: noTxBlobWantListRepository,
	}
	badgerTestAdaptersFactory := testAdaptersFactory()
	testTransactionProvider := badger.NewTestTransactionProvider(db, testAdaptersDependencies, badgerTestAdaptersFactory)
	badgerTestAdaptersDependencies := &badger.TestAdaptersDependencies{
		BanListHasher:        banListHasherMock,
		CurrentTimeProvider:  currentTimeProviderMock,
		RawMessageIdentifier: rawMessageIdentifierMock,
		LocalIdentity:        public,
	}
	badgerNoTxTestAdapters := BadgerNoTxTestAdapters{
		NoTxTestAdapters:    testAdapters,
		TransactionProvider: testTransactionProvider,
		Dependencies:        badgerTestAdaptersDependencies,
	}
	return badgerNoTxTestAdapters
}

func BuildBadgerTestAdapters(t *testing.T) BadgerTestAdapters {
	db := fixtures.Badger(t)
	banListHasherMock := mocks.NewBanListHasherMock()
	currentTimeProviderMock := mocks.NewCurrentTimeProviderMock()
	rawMessageIdentifierMock := mocks.NewRawMessageIdentifierMock()
	public := fixtures.SomePublicIdentity()
	testAdaptersDependencies := badger.TestAdaptersDependencies{
		BanListHasher:        banListHasherMock,
		CurrentTimeProvider:  currentTimeProviderMock,
		RawMessageIdentifier: rawMessageIdentifierMock,
		LocalIdentity:        public,
	}
	badgerTestAdaptersFactory := testAdaptersFactory()
	testTransactionProvider := badger.NewTestTransactionProvider(db, testAdaptersDependencies, badgerTestAdaptersFactory)
	badgerTestAdaptersDependencies := &badger.TestAdaptersDependencies{
		BanListHasher:        banListHasherMock,
		CurrentTimeProvider:  currentTimeProviderMock,
		RawMessageIdentifier: rawMessageIdentifierMock,
		LocalIdentity:        public,
	}
	badgerTestAdapters := BadgerTestAdapters{
		TransactionProvider: testTransactionProvider,
		Dependencies:        badgerTestAdaptersDependencies,
	}
	return badgerTestAdapters
}

func buildTestBadgerNoTxTxAdapters(txn *badger2.Txn, testAdaptersDependencies badger.TestAdaptersDependencies) (notx.TxAdapters, error) {
	banListHasherMock := testAdaptersDependencies.BanListHasher
	banListRepository := badger.NewBanListRepository(txn, banListHasherMock)
	blobRepository := badger.NewBlobRepository(txn)
	currentTimeProviderMock := testAdaptersDependencies.CurrentTimeProvider
	blobWantListRepository := badger.NewBlobWantListRepository(txn, currentTimeProviderMock)
	feedWantListRepository := badger.NewFeedWantListRepository(txn, currentTimeProviderMock)
	rawMessageIdentifierMock := testAdaptersDependencies.RawMessageIdentifier
	messageRepository := badger.NewMessageRepository(txn, rawMessageIdentifierMock)
	receiveLogRepository := badger.NewReceiveLogRepository(txn, messageRepository)
	public := testAdaptersDependencies.LocalIdentity
	hops := fixtures.SomeHops()
	socialGraphRepository := badger.NewSocialGraphRepository(txn, public, hops, banListRepository)
	pubRepository := badger.NewPubRepository(txn)
	messageContentMappings := transport.DefaultMappings()
	logger := fixtures.SomeLogger()
	marshaler, err := transport.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		return notx.TxAdapters{}, err
	}
	scanner := blobs.NewScanner()
	parser := content.NewParser(marshaler, scanner)
	messageHMAC := formats.NewDefaultMessageHMAC()
	scuttlebutt := formats.NewScuttlebutt(parser, messageHMAC)
	feedRepository := badger.NewFeedRepository(txn, socialGraphRepository, receiveLogRepository, messageRepository, pubRepository, blobRepository, banListRepository, scuttlebutt)
	txAdapters := notx.TxAdapters{
		BanListRepository:      banListRepository,
		BlobRepository:         blobRepository,
		BlobWantListRepository: blobWantListRepository,
		FeedWantListRepository: feedWantListRepository,
		MessageRepository:      messageRepository,
		ReceiveLogRepository:   receiveLogRepository,
		SocialGraphRepository:  socialGraphRepository,
		PubRepository:          pubRepository,
		FeedRepository:         feedRepository,
	}
	return txAdapters, nil
}

func buildBadgerNoTxTxAdapters(txn *badger2.Txn, public identity.Public, config Config, logger logging.Logger) (notx.TxAdapters, error) {
	banListHasher := adapters.NewBanListHasher()
	banListRepository := badger.NewBanListRepository(txn, banListHasher)
	blobRepository := badger.NewBlobRepository(txn)
	currentTimeProvider := adapters.NewCurrentTimeProvider()
	blobWantListRepository := badger.NewBlobWantListRepository(txn, currentTimeProvider)
	feedWantListRepository := badger.NewFeedWantListRepository(txn, currentTimeProvider)
	messageContentMappings := transport.DefaultMappings()
	marshaler, err := transport.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		return notx.TxAdapters{}, err
	}
	scanner := blobs.NewScanner()
	parser := content.NewParser(marshaler, scanner)
	messageHMAC := extractMessageHMACFromConfig(config)
	scuttlebutt := formats.NewScuttlebutt(parser, messageHMAC)
	v := newFormats(scuttlebutt)
	rawMessageIdentifier := formats.NewRawMessageIdentifier(v)
	messageRepository := badger.NewMessageRepository(txn, rawMessageIdentifier)
	receiveLogRepository := badger.NewReceiveLogRepository(txn, messageRepository)
	hops := extractHopsFromConfig(config)
	socialGraphRepository := badger.NewSocialGraphRepository(txn, public, hops, banListRepository)
	pubRepository := badger.NewPubRepository(txn)
	feedRepository := badger.NewFeedRepository(txn, socialGraphRepository, receiveLogRepository, messageRepository, pubRepository, blobRepository, banListRepository, scuttlebutt)
	txAdapters := notx.TxAdapters{
		BanListRepository:      banListRepository,
		BlobRepository:         blobRepository,
		BlobWantListRepository: blobWantListRepository,
		FeedWantListRepository: feedWantListRepository,
		MessageRepository:      messageRepository,
		ReceiveLogRepository:   receiveLogRepository,
		SocialGraphRepository:  socialGraphRepository,
		PubRepository:          pubRepository,
		FeedRepository:         feedRepository,
	}
	return txAdapters, nil
}

func buildBadgerTestAdapters(txn *badger2.Txn, testAdaptersDependencies badger.TestAdaptersDependencies) (badger.TestAdapters, error) {
	banListHasherMock := testAdaptersDependencies.BanListHasher
	banListRepository := badger.NewBanListRepository(txn, banListHasherMock)
	blobRepository := badger.NewBlobRepository(txn)
	currentTimeProviderMock := testAdaptersDependencies.CurrentTimeProvider
	blobWantListRepository := badger.NewBlobWantListRepository(txn, currentTimeProviderMock)
	feedWantListRepository := badger.NewFeedWantListRepository(txn, currentTimeProviderMock)
	rawMessageIdentifierMock := testAdaptersDependencies.RawMessageIdentifier
	messageRepository := badger.NewMessageRepository(txn, rawMessageIdentifierMock)
	receiveLogRepository := badger.NewReceiveLogRepository(txn, messageRepository)
	public := testAdaptersDependencies.LocalIdentity
	hops := fixtures.SomeHops()
	socialGraphRepository := badger.NewSocialGraphRepository(txn, public, hops, banListRepository)
	pubRepository := badger.NewPubRepository(txn)
	messageContentMappings := transport.DefaultMappings()
	logger := fixtures.SomeLogger()
	marshaler, err := transport.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		return badger.TestAdapters{}, err
	}
	scanner := blobs.NewScanner()
	parser := content.NewParser(marshaler, scanner)
	messageHMAC := formats.NewDefaultMessageHMAC()
	scuttlebutt := formats.NewScuttlebutt(parser, messageHMAC)
	feedRepository := badger.NewFeedRepository(txn, socialGraphRepository, receiveLogRepository, messageRepository, pubRepository, blobRepository, banListRepository, scuttlebutt)
	testAdapters := badger.TestAdapters{
		BanListRepository:      banListRepository,
		BlobRepository:         blobRepository,
		BlobWantListRepository: blobWantListRepository,
		FeedWantListRepository: feedWantListRepository,
		MessageRepository:      messageRepository,
		ReceiveLogRepository:   receiveLogRepository,
		SocialGraphRepository:  socialGraphRepository,
		PubRepository:          pubRepository,
		FeedRepository:         feedRepository,
	}
	return testAdapters, nil
}

func BuildTestCommands(t *testing.T) (TestCommands, error) {
	dialerMock := mocks.NewDialerMock()
	private, err := identity.NewPrivate()
	if err != nil {
		return TestCommands{}, err
	}
	roomsAliasRegisterHandler := commands.NewRoomsAliasRegisterHandler(dialerMock, private)
	roomsAliasRevokeHandler := commands.NewRoomsAliasRevokeHandler(dialerMock)
	peerManagerMock := mocks2.NewPeerManagerMock()
	processRoomAttendantEventHandler := commands.NewProcessRoomAttendantEventHandler(peerManagerMock)
	disconnectAllHandler := commands.NewDisconnectAllHandler(peerManagerMock)
	feedWantListRepositoryMock := mocks.NewFeedWantListRepositoryMock()
	feedRepositoryMock := mocks.NewFeedRepositoryMock()
	receiveLogRepositoryMock := mocks.NewReceiveLogRepositoryMock()
	commandsAdapters := commands.Adapters{
		FeedWantList: feedWantListRepositoryMock,
		Feed:         feedRepositoryMock,
		ReceiveLog:   receiveLogRepositoryMock,
	}
	mockCommandsTransactionProvider := mocks.NewMockCommandsTransactionProvider(commandsAdapters)
	currentTimeProviderMock := mocks.NewCurrentTimeProviderMock()
	downloadFeedHandler := commands.NewDownloadFeedHandler(mockCommandsTransactionProvider, currentTimeProviderMock)
	inviteRedeemerMock := mocks.NewInviteRedeemerMock()
	logger := fixtures.TestLogger(t)
	redeemInviteHandler := commands.NewRedeemInviteHandler(inviteRedeemerMock, private, logger)
	public := privateIdentityToPublicIdentity(private)
	peerInitializerMock := mocks.NewPeerInitializerMock()
	acceptTunnelConnectHandler := commands.NewAcceptTunnelConnectHandler(public, peerInitializerMock)
	goSSBRepoReaderMock := mocks.NewGoSSBRepoReaderMock()
	contentParser := mocks.NewContentParser()
	migrationHandlerImportDataFromGoSSB := commands.NewMigrationHandlerImportDataFromGoSSB(goSSBRepoReaderMock, mockCommandsTransactionProvider, contentParser, logger)
	testCommands := TestCommands{
		RoomsAliasRegister:           roomsAliasRegisterHandler,
		RoomsAliasRevoke:             roomsAliasRevokeHandler,
		ProcessRoomAttendantEvent:    processRoomAttendantEventHandler,
		DisconnectAll:                disconnectAllHandler,
		DownloadFeed:                 downloadFeedHandler,
		RedeemInvite:                 redeemInviteHandler,
		AcceptTunnelConnect:          acceptTunnelConnectHandler,
		MigrationImportDataFromGoSSB: migrationHandlerImportDataFromGoSSB,
		PeerManager:                  peerManagerMock,
		Dialer:                       dialerMock,
		FeedWantListRepository:       feedWantListRepositoryMock,
		CurrentTimeProvider:          currentTimeProviderMock,
		InviteRedeemer:               inviteRedeemerMock,
		Local:                        public,
		PeerInitializer:              peerInitializerMock,
		GoSSBRepoReader:              goSSBRepoReaderMock,
		FeedRepository:               feedRepositoryMock,
		ReceiveLog:                   receiveLogRepositoryMock,
	}
	return testCommands, nil
}

func BuildTestQueries(t *testing.T) (TestQueries, error) {
	feedRepositoryMock := mocks.NewFeedRepositoryMock()
	receiveLogRepositoryMock := mocks.NewReceiveLogRepositoryMock()
	messageRepositoryMock := mocks.NewMessageRepositoryMock()
	socialGraphRepositoryMock := mocks.NewSocialGraphRepositoryMock()
	feedWantListRepositoryMock := mocks.NewFeedWantListRepositoryMock()
	banListRepositoryMock := mocks.NewBanListRepositoryMock()
	queriesAdapters := queries.Adapters{
		Feed:         feedRepositoryMock,
		ReceiveLog:   receiveLogRepositoryMock,
		Message:      messageRepositoryMock,
		SocialGraph:  socialGraphRepositoryMock,
		FeedWantList: feedWantListRepositoryMock,
		BanList:      banListRepositoryMock,
	}
	mockQueriesTransactionProvider := mocks.NewMockQueriesTransactionProvider(queriesAdapters)
	messagePubSub := pubsub.NewMessagePubSub()
	messagePubSubMock := mocks.NewMessagePubSubMock(messagePubSub)
	logger := fixtures.TestLogger(t)
	createHistoryStreamHandler := queries.NewCreateHistoryStreamHandler(mockQueriesTransactionProvider, messagePubSubMock, logger)
	receiveLogHandler := queries.NewReceiveLogHandler(mockQueriesTransactionProvider)
	private, err := identity.NewPrivate()
	if err != nil {
		return TestQueries{}, err
	}
	public := privateIdentityToPublicIdentity(private)
	publishedLogHandler, err := queries.NewPublishedLogHandler(mockQueriesTransactionProvider, public)
	if err != nil {
		return TestQueries{}, err
	}
	peerManagerMock := mocks2.NewPeerManagerMock()
	statusHandler := queries.NewStatusHandler(mockQueriesTransactionProvider, peerManagerMock)
	blobStorageMock := mocks.NewBlobStorageMock()
	getBlobHandler, err := queries.NewGetBlobHandler(blobStorageMock)
	if err != nil {
		return TestQueries{}, err
	}
	blobDownloadedPubSubMock := mocks.NewBlobDownloadedPubSubMock()
	blobDownloadedEventsHandler := queries.NewBlobDownloadedEventsHandler(blobDownloadedPubSubMock)
	dialerMock := mocks.NewDialerMock()
	roomsListAliasesHandler, err := queries.NewRoomsListAliasesHandler(dialerMock, public)
	if err != nil {
		return TestQueries{}, err
	}
	getMessageHandler := queries.NewGetMessageHandler(mockQueriesTransactionProvider)
	getMessageBySequenceHandler := queries.NewGetMessageBySequenceHandler(mockQueriesTransactionProvider)
	appQueries := app.Queries{
		CreateHistoryStream:  createHistoryStreamHandler,
		ReceiveLog:           receiveLogHandler,
		PublishedLog:         publishedLogHandler,
		Status:               statusHandler,
		GetBlob:              getBlobHandler,
		BlobDownloadedEvents: blobDownloadedEventsHandler,
		RoomsListAliases:     roomsListAliasesHandler,
		GetMessage:           getMessageHandler,
		GetMessageBySequence: getMessageBySequenceHandler,
	}
	wantedFeedsProvider := queries.NewWantedFeedsProvider(mockQueriesTransactionProvider)
	testQueries := TestQueries{
		Queries:                appQueries,
		WantedFeedsProvider:    wantedFeedsProvider,
		FeedRepository:         feedRepositoryMock,
		MessageRepository:      messageRepositoryMock,
		ReceiveLogRepository:   receiveLogRepositoryMock,
		SocialGraphRepository:  socialGraphRepositoryMock,
		FeedWantListRepository: feedWantListRepositoryMock,
		BanListRepository:      banListRepositoryMock,
		MessagePubSub:          messagePubSubMock,
		PeerManager:            peerManagerMock,
		BlobStorage:            blobStorageMock,
		Dialer:                 dialerMock,
		LocalIdentity:          public,
	}
	return testQueries, nil
}

func buildBadgerCommandsAdapters(txn *badger2.Txn, public identity.Public, config Config, logger logging.Logger) (commands.Adapters, error) {
	hops := extractHopsFromConfig(config)
	banListHasher := adapters.NewBanListHasher()
	banListRepository := badger.NewBanListRepository(txn, banListHasher)
	socialGraphRepository := badger.NewSocialGraphRepository(txn, public, hops, banListRepository)
	messageContentMappings := transport.DefaultMappings()
	marshaler, err := transport.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		return commands.Adapters{}, err
	}
	scanner := blobs.NewScanner()
	parser := content.NewParser(marshaler, scanner)
	messageHMAC := extractMessageHMACFromConfig(config)
	scuttlebutt := formats.NewScuttlebutt(parser, messageHMAC)
	v := newFormats(scuttlebutt)
	rawMessageIdentifier := formats.NewRawMessageIdentifier(v)
	messageRepository := badger.NewMessageRepository(txn, rawMessageIdentifier)
	receiveLogRepository := badger.NewReceiveLogRepository(txn, messageRepository)
	pubRepository := badger.NewPubRepository(txn)
	blobRepository := badger.NewBlobRepository(txn)
	feedRepository := badger.NewFeedRepository(txn, socialGraphRepository, receiveLogRepository, messageRepository, pubRepository, blobRepository, banListRepository, scuttlebutt)
	currentTimeProvider := adapters.NewCurrentTimeProvider()
	blobWantListRepository := badger.NewBlobWantListRepository(txn, currentTimeProvider)
	feedWantListRepository := badger.NewFeedWantListRepository(txn, currentTimeProvider)
	commandsAdapters := commands.Adapters{
		Feed:         feedRepository,
		ReceiveLog:   receiveLogRepository,
		SocialGraph:  socialGraphRepository,
		BlobWantList: blobWantListRepository,
		FeedWantList: feedWantListRepository,
		BanList:      banListRepository,
	}
	return commandsAdapters, nil
}

func buildBadgerQueriesAdapters(txn *badger2.Txn, public identity.Public, config Config, logger logging.Logger) (queries.Adapters, error) {
	hops := extractHopsFromConfig(config)
	banListHasher := adapters.NewBanListHasher()
	banListRepository := badger.NewBanListRepository(txn, banListHasher)
	socialGraphRepository := badger.NewSocialGraphRepository(txn, public, hops, banListRepository)
	messageContentMappings := transport.DefaultMappings()
	marshaler, err := transport.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		return queries.Adapters{}, err
	}
	scanner := blobs.NewScanner()
	parser := content.NewParser(marshaler, scanner)
	messageHMAC := extractMessageHMACFromConfig(config)
	scuttlebutt := formats.NewScuttlebutt(parser, messageHMAC)
	v := newFormats(scuttlebutt)
	rawMessageIdentifier := formats.NewRawMessageIdentifier(v)
	messageRepository := badger.NewMessageRepository(txn, rawMessageIdentifier)
	receiveLogRepository := badger.NewReceiveLogRepository(txn, messageRepository)
	pubRepository := badger.NewPubRepository(txn)
	blobRepository := badger.NewBlobRepository(txn)
	feedRepository := badger.NewFeedRepository(txn, socialGraphRepository, receiveLogRepository, messageRepository, pubRepository, blobRepository, banListRepository, scuttlebutt)
	currentTimeProvider := adapters.NewCurrentTimeProvider()
	feedWantListRepository := badger.NewFeedWantListRepository(txn, currentTimeProvider)
	queriesAdapters := queries.Adapters{
		Feed:         feedRepository,
		ReceiveLog:   receiveLogRepository,
		Message:      messageRepository,
		SocialGraph:  socialGraphRepository,
		FeedWantList: feedWantListRepository,
		BanList:      banListRepository,
	}
	return queriesAdapters, nil
}

// BuildService creates a new service which uses the provided context as a long-term context used as a base context for
// e.g. established connections.
func BuildService(private identity.Private, config Config) (Service, func(), error) {
	networkKey := extractNetworkKeyFromConfig(config)
	currentTimeProvider := adapters.NewCurrentTimeProvider()
	handshaker, err := boxstream.NewHandshaker(private, networkKey, currentTimeProvider)
	if err != nil {
		return Service{}, nil, err
	}
	requestPubSub := pubsub.NewRequestPubSub()
	connectionIdGenerator := rpc.NewConnectionIdGenerator()
	newPeerPubSub := pubsub.NewNewPeerPubSub()
	loggingSystem := extractLoggingSystemFromConfig(config)
	logger := newContextLogger(loggingSystem)
	peerInitializer := transport2.NewPeerInitializer(handshaker, requestPubSub, connectionIdGenerator, newPeerPubSub, logger)
	dialer, err := network.NewDialer(peerInitializer, logger)
	if err != nil {
		return Service{}, nil, err
	}
	inviteDialer := invites.NewInviteDialer(dialer, networkKey, requestPubSub, connectionIdGenerator, currentTimeProvider, logger)
	inviteRedeemer := invites2.NewInviteRedeemer(inviteDialer, logger)
	redeemInviteHandler := commands.NewRedeemInviteHandler(inviteRedeemer, private, logger)
	db, cleanup, err := newBadger(loggingSystem, logger, config)
	if err != nil {
		return Service{}, nil, err
	}
	public := privateIdentityToPublicIdentity(private)
	commandsAdaptersFactory := badgerCommandsAdaptersFactory(config, public, logger)
	commandsTransactionProvider := badger.NewCommandsTransactionProvider(db, commandsAdaptersFactory)
	messageContentMappings := transport.DefaultMappings()
	marshaler, err := transport.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	followHandler := commands.NewFollowHandler(commandsTransactionProvider, private, marshaler, logger)
	transactionRawMessagePublisher := commands.NewTransactionRawMessagePublisher(commandsTransactionProvider)
	publishRawHandler := commands.NewPublishRawHandler(transactionRawMessagePublisher, private)
	publishRawAsIdentityHandler := commands.NewPublishRawAsIdentityHandler(transactionRawMessagePublisher)
	downloadFeedHandler := commands.NewDownloadFeedHandler(commandsTransactionProvider, currentTimeProvider)
	peerManagerConfig := extractPeerManagerConfigFromConfig(config)
	tunnelDialer := tunnel.NewDialer(peerInitializer)
	peerManager := domain.NewPeerManager(peerManagerConfig, dialer, tunnelDialer, logger)
	connectHandler := commands.NewConnectHandler(peerManager, logger)
	disconnectAllHandler := commands.NewDisconnectAllHandler(peerManager)
	downloadBlobHandler := commands.NewDownloadBlobHandler(commandsTransactionProvider, currentTimeProvider)
	filesystemStorage, err := newFilesystemStorage(logger, config)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	createBlobHandler := commands.NewCreateBlobHandler(filesystemStorage)
	addToBanListHandler := commands.NewAddToBanListHandler(commandsTransactionProvider)
	removeFromBanListHandler := commands.NewRemoveFromBanListHandler(commandsTransactionProvider)
	roomsAliasRegisterHandler := commands.NewRoomsAliasRegisterHandler(dialer, private)
	roomsAliasRevokeHandler := commands.NewRoomsAliasRevokeHandler(dialer)
	badgerStorage := migrations.NewBadgerStorage(db)
	runner := migrations2.NewRunner(badgerStorage, logger)
	goSSBRepoReader := migrations.NewGoSSBRepoReader(logger)
	migrationHandlerDeleteGoSSBRepositoryInOldFormat := commands.NewMigrationHandlerDeleteGoSSBRepositoryInOldFormat(goSSBRepoReader, logger)
	scanner := blobs.NewScanner()
	parser := content.NewParser(marshaler, scanner)
	migrationHandlerImportDataFromGoSSB := commands.NewMigrationHandlerImportDataFromGoSSB(goSSBRepoReader, commandsTransactionProvider, parser, logger)
	commandsMigrations := commands.Migrations{
		MigrationDeleteGoSSBRepositoryInOldFormat: migrationHandlerDeleteGoSSBRepositoryInOldFormat,
		MigrationImportDataFromGoSSB:              migrationHandlerImportDataFromGoSSB,
	}
	commandDeleteGoSsbRepositoryInOldFormatAdapter := newCommandDeleteGoSsbRepositoryInOldFormatAdapter(config, commandsMigrations)
	commandImportDataFromGoSSBHandlerAdapter := newCommandImportDataFromGoSSBHandlerAdapter(config, commandsMigrations)
	v := newMigrationsList(commandDeleteGoSsbRepositoryInOldFormatAdapter, commandImportDataFromGoSSBHandlerAdapter)
	migrationsMigrations, err := migrations2.NewMigrations(v)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	runMigrationsHandler := commands.NewRunMigrationsHandler(runner, migrationsMigrations)
	appCommands := app.Commands{
		RedeemInvite:         redeemInviteHandler,
		Follow:               followHandler,
		PublishRaw:           publishRawHandler,
		PublishRawAsIdentity: publishRawAsIdentityHandler,
		DownloadFeed:         downloadFeedHandler,
		Connect:              connectHandler,
		DisconnectAll:        disconnectAllHandler,
		DownloadBlob:         downloadBlobHandler,
		CreateBlob:           createBlobHandler,
		AddToBanList:         addToBanListHandler,
		RemoveFromBanList:    removeFromBanListHandler,
		RoomsAliasRegister:   roomsAliasRegisterHandler,
		RoomsAliasRevoke:     roomsAliasRevokeHandler,
		RunMigrations:        runMigrationsHandler,
	}
	queriesAdaptersFactory := badgerQueriesAdaptersFactory(config, public, logger)
	queriesTransactionProvider := badger.NewQueriesTransactionProvider(db, queriesAdaptersFactory)
	messagePubSub := pubsub.NewMessagePubSub()
	createHistoryStreamHandler := queries.NewCreateHistoryStreamHandler(queriesTransactionProvider, messagePubSub, logger)
	receiveLogHandler := queries.NewReceiveLogHandler(queriesTransactionProvider)
	publishedLogHandler, err := queries.NewPublishedLogHandler(queriesTransactionProvider, public)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	statusHandler := queries.NewStatusHandler(queriesTransactionProvider, peerManager)
	getBlobHandler, err := queries.NewGetBlobHandler(filesystemStorage)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	blobDownloadedPubSub := pubsub.NewBlobDownloadedPubSub()
	blobDownloadedEventsHandler := queries.NewBlobDownloadedEventsHandler(blobDownloadedPubSub)
	roomsListAliasesHandler, err := queries.NewRoomsListAliasesHandler(dialer, public)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	getMessageHandler := queries.NewGetMessageHandler(queriesTransactionProvider)
	getMessageBySequenceHandler := queries.NewGetMessageBySequenceHandler(queriesTransactionProvider)
	appQueries := app.Queries{
		CreateHistoryStream:  createHistoryStreamHandler,
		ReceiveLog:           receiveLogHandler,
		PublishedLog:         publishedLogHandler,
		Status:               statusHandler,
		GetBlob:              getBlobHandler,
		BlobDownloadedEvents: blobDownloadedEventsHandler,
		RoomsListAliases:     roomsListAliasesHandler,
		GetMessage:           getMessageHandler,
		GetMessageBySequence: getMessageBySequenceHandler,
	}
	application := app.Application{
		Commands: appCommands,
		Queries:  appQueries,
	}
	listener, err := newListener(peerInitializer, config, logger)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	discoverer, err := local.NewDiscoverer(public, logger)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	processNewLocalDiscoveryHandler := commands.NewProcessNewLocalDiscoveryHandler(peerManager)
	networkDiscoverer := network2.NewDiscoverer(discoverer, processNewLocalDiscoveryHandler, logger)
	establishNewConnectionsHandler := commands.NewEstablishNewConnectionsHandler(peerManager)
	connectionEstablisher := network2.NewConnectionEstablisher(establishNewConnectionsHandler, logger)
	handlerBlobsGet := rpc2.NewHandlerBlobsGet(getBlobHandler)
	txAdaptersFactory := noTxTxAdaptersFactory(public, config, logger)
	txAdaptersFactoryTransactionProvider := notx.NewTxAdaptersFactoryTransactionProvider(db, txAdaptersFactory)
	noTxBlobWantListRepository := notx.NewNoTxBlobWantListRepository(txAdaptersFactoryTransactionProvider, logger)
	noTxBlobsRepository := notx.NewNoTxBlobsRepository(txAdaptersFactoryTransactionProvider)
	storageBlobsThatShouldBePushedProvider, err := replication.NewStorageBlobsThatShouldBePushedProvider(noTxBlobsRepository, public, currentTimeProvider)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	blobsGetDownloader := replication.NewBlobsGetDownloader(filesystemStorage, logger)
	hasHandler := replication.NewHasHandler(filesystemStorage, noTxBlobWantListRepository, blobsGetDownloader, blobDownloadedPubSub, logger)
	diManagedWantsProcessFactory := newManagedWantsProcessFactory(noTxBlobWantListRepository, storageBlobsThatShouldBePushedProvider, filesystemStorage, hasHandler, logger)
	manager := replication.NewManager(diManagedWantsProcessFactory, logger)
	createWantsHandler := commands.NewCreateWantsHandler(manager)
	handlerBlobsCreateWants := rpc2.NewHandlerBlobsCreateWants(createWantsHandler)
	sessionTracker := ebt.NewSessionTracker()
	messageHMAC := extractMessageHMACFromConfig(config)
	scuttlebutt := formats.NewScuttlebutt(parser, messageHMAC)
	v2 := newFormats(scuttlebutt)
	rawMessageIdentifier := formats.NewRawMessageIdentifier(v2)
	wantedFeedsProvider := queries.NewWantedFeedsProvider(queriesTransactionProvider)
	wantedFeedsCache := replication2.NewWantedFeedsCache(wantedFeedsProvider)
	messageBuffer := commands.NewMessageBuffer(commandsTransactionProvider, rawMessageIdentifier, wantedFeedsCache, logger)
	rawMessageHandler := commands.NewRawMessageHandler(rawMessageIdentifier, messageBuffer, logger)
	createHistoryStreamHandlerAdapter := ebt2.NewCreateHistoryStreamHandlerAdapter(createHistoryStreamHandler)
	sessionRunner := ebt.NewSessionRunner(logger, rawMessageHandler, wantedFeedsCache, createHistoryStreamHandlerAdapter)
	gossipManager := gossip.NewManager(logger, wantedFeedsCache)
	gossipReplicator, err := gossip.NewGossipReplicator(gossipManager, rawMessageHandler, logger)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	replicator := ebt.NewReplicator(sessionTracker, sessionRunner, gossipReplicator, logger)
	handleIncomingEbtReplicateHandler := commands.NewHandleIncomingEbtReplicateHandler(replicator)
	handlerEbtReplicate := rpc2.NewHandlerEbtReplicate(handleIncomingEbtReplicateHandler)
	acceptTunnelConnectHandler := commands.NewAcceptTunnelConnectHandler(public, peerInitializer)
	handlerTunnelConnect := rpc2.NewHandlerTunnelConnect(acceptTunnelConnectHandler)
	v3 := rpc2.NewMuxHandlers(handlerBlobsGet, handlerBlobsCreateWants, handlerEbtReplicate, handlerTunnelConnect)
	handlerCreateHistoryStream := rpc2.NewHandlerCreateHistoryStream(createHistoryStreamHandler, logger)
	v4 := rpc2.NewMuxClosingHandlers(handlerCreateHistoryStream)
	muxMux, err := mux.NewMux(logger, v3, v4)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	requestSubscriber := pubsub2.NewRequestSubscriber(requestPubSub, muxMux)
	roomAttendantEventPubSub := pubsub.NewRoomAttendantEventPubSub()
	processRoomAttendantEventHandler := commands.NewProcessRoomAttendantEventHandler(peerManager)
	roomAttendantEventSubscriber := pubsub2.NewRoomAttendantEventSubscriber(roomAttendantEventPubSub, processRoomAttendantEventHandler, logger)
	negotiator := replication2.NewNegotiator(logger, replicator, gossipReplicator)
	replicationReplicator := replication.NewReplicator(manager)
	peerRPCAdapter := rooms.NewPeerRPCAdapter(logger)
	roomsScanner := rooms.NewScanner(peerRPCAdapter, peerRPCAdapter, roomAttendantEventPubSub, logger)
	acceptNewPeerHandler := commands.NewAcceptNewPeerHandler(peerManager, negotiator, replicationReplicator, roomsScanner, logger)
	newPeerSubscriber := pubsub2.NewNewPeerSubscriber(newPeerPubSub, acceptNewPeerHandler, logger)
	advertiser, err := newAdvertiser(public, config)
	if err != nil {
		cleanup()
		return Service{}, nil, err
	}
	garbageCollector := badger.NewGarbageCollector(db, logger)
	noTxFeedWantListRepository := notx.NewNoTxFeedWantListRepository(txAdaptersFactoryTransactionProvider, logger)
	service := NewService(application, listener, networkDiscoverer, connectionEstablisher, requestSubscriber, roomAttendantEventSubscriber, newPeerSubscriber, advertiser, messageBuffer, createHistoryStreamHandler, garbageCollector, noTxFeedWantListRepository, noTxBlobWantListRepository)
	return service, func() {
		cleanup()
	}, nil
}

func buildIntegrationTestsService(t *testing.T) (IntegrationTestsService, func(), error) {
	private := fixtures.SomePrivateIdentity()
	config := newIntegrationTestConfig(t)
	networkKey := extractNetworkKeyFromConfig(config)
	currentTimeProvider := adapters.NewCurrentTimeProvider()
	handshaker, err := boxstream.NewHandshaker(private, networkKey, currentTimeProvider)
	if err != nil {
		return IntegrationTestsService{}, nil, err
	}
	requestPubSub := pubsub.NewRequestPubSub()
	connectionIdGenerator := rpc.NewConnectionIdGenerator()
	newPeerPubSub := pubsub.NewNewPeerPubSub()
	loggingSystem := extractLoggingSystemFromConfig(config)
	logger := newContextLogger(loggingSystem)
	peerInitializer := transport2.NewPeerInitializer(handshaker, requestPubSub, connectionIdGenerator, newPeerPubSub, logger)
	dialer, err := network.NewDialer(peerInitializer, logger)
	if err != nil {
		return IntegrationTestsService{}, nil, err
	}
	inviteDialer := invites.NewInviteDialer(dialer, networkKey, requestPubSub, connectionIdGenerator, currentTimeProvider, logger)
	inviteRedeemer := invites2.NewInviteRedeemer(inviteDialer, logger)
	redeemInviteHandler := commands.NewRedeemInviteHandler(inviteRedeemer, private, logger)
	db, cleanup, err := newBadger(loggingSystem, logger, config)
	if err != nil {
		return IntegrationTestsService{}, nil, err
	}
	public := privateIdentityToPublicIdentity(private)
	commandsAdaptersFactory := badgerCommandsAdaptersFactory(config, public, logger)
	commandsTransactionProvider := badger.NewCommandsTransactionProvider(db, commandsAdaptersFactory)
	messageContentMappings := transport.DefaultMappings()
	marshaler, err := transport.NewMarshaler(messageContentMappings, logger)
	if err != nil {
		cleanup()
		return IntegrationTestsService{}, nil, err
	}
	followHandler := commands.NewFollowHandler(commandsTransactionProvider, private, marshaler, logger)
	transactionRawMessagePublisher := commands.NewTransactionRawMessagePublisher(commandsTransactionProvider)
	publishRawHandler := commands.NewPublishRawHandler(transactionRawMessagePublisher, private)
	publishRawAsIdentityHandler := commands.NewPublishRawAsIdentityHandler(transactionRawMessagePublisher)
	downloadFeedHandler := commands.NewDownloadFeedHandler(commandsTransactionProvider, currentTimeProvider)
	peerManagerConfig := extractPeerManagerConfigFromConfig(config)
	tunnelDialer := tunnel.NewDialer(peerInitializer)
	peerManager := domain.NewPeerManager(peerManagerConfig, dialer, tunnelDialer, logger)
	connectHandler := commands.NewConnectHandler(peerManager, logger)
	disconnectAllHandler := commands.NewDisconnectAllHandler(peerManager)
	downloadBlobHandler := commands.NewDownloadBlobHandler(commandsTransactionProvider, currentTimeProvider)
	filesystemStorage, err := newFilesystemStorage(logger, config)
	if err != nil {
		cleanup()
		return IntegrationTestsService{}, nil, err
	}
	createBlobHandler := commands.NewCreateBlobHandler(filesystemStorage)
	addToBanListHandler := commands.NewAddToBanListHandler(commandsTransactionProvider)
	removeFromBanListHandler := commands.NewRemoveFromBanListHandler(commandsTransactionProvider)
	roomsAliasRegisterHandler := commands.NewRoomsAliasRegisterHandler(dialer, private)
	roomsAliasRevokeHandler := commands.NewRoomsAliasRevokeHandler(dialer)
	badgerStorage := migrations.NewBadgerStorage(db)
	runner := migrations2.NewRunner(badgerStorage, logger)
	goSSBRepoReader := migrations.NewGoSSBRepoReader(logger)
	migrationHandlerDeleteGoSSBRepositoryInOldFormat := commands.NewMigrationHandlerDeleteGoSSBRepositoryInOldFormat(goSSBRepoReader, logger)
	scanner := blobs.NewScanner()
	parser := content.NewParser(marshaler, scanner)
	migrationHandlerImportDataFromGoSSB := commands.NewMigrationHandlerImportDataFromGoSSB(goSSBRepoReader, commandsTransactionProvider, parser, logger)
	commandsMigrations := commands.Migrations{
		MigrationDeleteGoSSBRepositoryInOldFormat: migrationHandlerDeleteGoSSBRepositoryInOldFormat,
		MigrationImportDataFromGoSSB:              migrationHandlerImportDataFromGoSSB,
	}
	commandDeleteGoSsbRepositoryInOldFormatAdapter := newCommandDeleteGoSsbRepositoryInOldFormatAdapter(config, commandsMigrations)
	commandImportDataFromGoSSBHandlerAdapter := newCommandImportDataFromGoSSBHandlerAdapter(config, commandsMigrations)
	v := newMigrationsList(commandDeleteGoSsbRepositoryInOldFormatAdapter, commandImportDataFromGoSSBHandlerAdapter)
	migrationsMigrations, err := migrations2.NewMigrations(v)
	if err != nil {
		cleanup()
		return IntegrationTestsService{}, nil, err
	}
	runMigrationsHandler := commands.NewRunMigrationsHandler(runner, migrationsMigrations)
	appCommands := app.Commands{
		RedeemInvite:         redeemInviteHandler,
		Follow:               followHandler,
		PublishRaw:           publishRawHandler,
		PublishRawAsIdentity: publishRawAsIdentityHandler,
		DownloadFeed:         downloadFeedHandler,
		Connect:              connectHandler,
		DisconnectAll:        disconnectAllHandler,
		DownloadBlob:         downloadBlobHandler,
		CreateBlob:           createBlobHandler,
		AddToBanList:         addToBanListHandler,
		RemoveFromBanList:    removeFromBanListHandler,
		RoomsAliasRegister:   roomsAliasRegisterHandler,
		RoomsAliasRevoke:     roomsAliasRevokeHandler,
		RunMigrations:        runMigrationsHandler,
	}
	queriesAdaptersFactory := badgerQueriesAdaptersFactory(config, public, logger)
	queriesTransactionProvider := badger.NewQueriesTransactionProvider(db, queriesAdaptersFactory)
	messagePubSub := pubsub.NewMessagePubSub()
	createHistoryStreamHandler := queries.NewCreateHistoryStreamHandler(queriesTransactionProvider, messagePubSub, logger)
	receiveLogHandler := queries.NewReceiveLogHandler(queriesTransactionProvider)
	publishedLogHandler, err := queries.NewPublishedLogHandler(queriesTransactionProvider, public)
	if err != nil {
		cleanup()
		return IntegrationTestsService{}, nil, err
	}
	statusHandler := queries.NewStatusHandler(queriesTransactionProvider, peerManager)
	getBlobHandler, err := queries.NewGetBlobHandler(filesystemStorage)
	if err != nil {
		cleanup()
		return IntegrationTestsService{}, nil, err
	}
	blobDownloadedPubSub := pubsub.NewBlobDownloadedPubSub()
	blobDownloadedEventsHandler := queries.NewBlobDownloadedEventsHandler(blobDownloadedPubSub)
	roomsListAliasesHandler, err := queries.NewRoomsListAliasesHandler(dialer, public)
	if err != nil {
		cleanup()
		return IntegrationTestsService{}, nil, err
	}
	getMessageHandler := queries.NewGetMessageHandler(queriesTransactionProvider)
	getMessageBySequenceHandler := queries.NewGetMessageBySequenceHandler(queriesTransactionProvider)
	appQueries := app.Queries{
		CreateHistoryStream:  createHistoryStreamHandler,
		ReceiveLog:           receiveLogHandler,
		PublishedLog:         publishedLogHandler,
		Status:               statusHandler,
		GetBlob:              getBlobHandler,
		BlobDownloadedEvents: blobDownloadedEventsHandler,
		RoomsListAliases:     roomsListAliasesHandler,
		GetMessage:           getMessageHandler,
		GetMessageBySequence: getMessageBySequenceHandler,
	}
	application := app.Application{
		Commands: appCommands,
		Queries:  appQueries,
	}
	listener, err := newListener(peerInitializer, config, logger)
	if err != nil {
		cleanup()
		return IntegrationTestsService{}, nil, err
	}
	discoverer, err := local.NewDiscoverer(public, logger)
	if err != nil {
		cleanup()
		return IntegrationTestsService{}, nil, err
	}
	processNewLocalDiscoveryHandler := commands.NewProcessNewLocalDiscoveryHandler(peerManager)
	networkDiscoverer := network2.NewDiscoverer(discoverer, processNewLocalDiscoveryHandler, logger)
	establishNewConnectionsHandler := commands.NewEstablishNewConnectionsHandler(peerManager)
	connectionEstablisher := network2.NewConnectionEstablisher(establishNewConnectionsHandler, logger)
	handlerBlobsGet := rpc2.NewHandlerBlobsGet(getBlobHandler)
	txAdaptersFactory := noTxTxAdaptersFactory(public, config, logger)
	txAdaptersFactoryTransactionProvider := notx.NewTxAdaptersFactoryTransactionProvider(db, txAdaptersFactory)
	noTxBlobWantListRepository := notx.NewNoTxBlobWantListRepository(txAdaptersFactoryTransactionProvider, logger)
	noTxBlobsRepository := notx.NewNoTxBlobsRepository(txAdaptersFactoryTransactionProvider)
	storageBlobsThatShouldBePushedProvider, err := replication.NewStorageBlobsThatShouldBePushedProvider(noTxBlobsRepository, public, currentTimeProvider)
	if err != nil {
		cleanup()
		return IntegrationTestsService{}, nil, err
	}
	blobsGetDownloader := replication.NewBlobsGetDownloader(filesystemStorage, logger)
	hasHandler := replication.NewHasHandler(filesystemStorage, noTxBlobWantListRepository, blobsGetDownloader, blobDownloadedPubSub, logger)
	diManagedWantsProcessFactory := newManagedWantsProcessFactory(noTxBlobWantListRepository, storageBlobsThatShouldBePushedProvider, filesystemStorage, hasHandler, logger)
	manager := replication.NewManager(diManagedWantsProcessFactory, logger)
	createWantsHandler := commands.NewCreateWantsHandler(manager)
	handlerBlobsCreateWants := rpc2.NewHandlerBlobsCreateWants(createWantsHandler)
	sessionTracker := ebt.NewSessionTracker()
	messageHMAC := extractMessageHMACFromConfig(config)
	scuttlebutt := formats.NewScuttlebutt(parser, messageHMAC)
	v2 := newFormats(scuttlebutt)
	rawMessageIdentifier := formats.NewRawMessageIdentifier(v2)
	wantedFeedsProvider := queries.NewWantedFeedsProvider(queriesTransactionProvider)
	wantedFeedsCache := replication2.NewWantedFeedsCache(wantedFeedsProvider)
	messageBuffer := commands.NewMessageBuffer(commandsTransactionProvider, rawMessageIdentifier, wantedFeedsCache, logger)
	rawMessageHandler := commands.NewRawMessageHandler(rawMessageIdentifier, messageBuffer, logger)
	createHistoryStreamHandlerAdapter := ebt2.NewCreateHistoryStreamHandlerAdapter(createHistoryStreamHandler)
	sessionRunner := ebt.NewSessionRunner(logger, rawMessageHandler, wantedFeedsCache, createHistoryStreamHandlerAdapter)
	gossipManager := gossip.NewManager(logger, wantedFeedsCache)
	gossipReplicator, err := gossip.NewGossipReplicator(gossipManager, rawMessageHandler, logger)
	if err != nil {
		cleanup()
		return IntegrationTestsService{}, nil, err
	}
	replicator := ebt.NewReplicator(sessionTracker, sessionRunner, gossipReplicator, logger)
	handleIncomingEbtReplicateHandler := commands.NewHandleIncomingEbtReplicateHandler(replicator)
	handlerEbtReplicate := rpc2.NewHandlerEbtReplicate(handleIncomingEbtReplicateHandler)
	acceptTunnelConnectHandler := commands.NewAcceptTunnelConnectHandler(public, peerInitializer)
	handlerTunnelConnect := rpc2.NewHandlerTunnelConnect(acceptTunnelConnectHandler)
	v3 := rpc2.NewMuxHandlers(handlerBlobsGet, handlerBlobsCreateWants, handlerEbtReplicate, handlerTunnelConnect)
	handlerCreateHistoryStream := rpc2.NewHandlerCreateHistoryStream(createHistoryStreamHandler, logger)
	v4 := rpc2.NewMuxClosingHandlers(handlerCreateHistoryStream)
	muxMux, err := mux.NewMux(logger, v3, v4)
	if err != nil {
		cleanup()
		return IntegrationTestsService{}, nil, err
	}
	requestSubscriber := pubsub2.NewRequestSubscriber(requestPubSub, muxMux)
	roomAttendantEventPubSub := pubsub.NewRoomAttendantEventPubSub()
	processRoomAttendantEventHandler := commands.NewProcessRoomAttendantEventHandler(peerManager)
	roomAttendantEventSubscriber := pubsub2.NewRoomAttendantEventSubscriber(roomAttendantEventPubSub, processRoomAttendantEventHandler, logger)
	negotiator := replication2.NewNegotiator(logger, replicator, gossipReplicator)
	replicationReplicator := replication.NewReplicator(manager)
	peerRPCAdapter := rooms.NewPeerRPCAdapter(logger)
	roomsScanner := rooms.NewScanner(peerRPCAdapter, peerRPCAdapter, roomAttendantEventPubSub, logger)
	acceptNewPeerHandler := commands.NewAcceptNewPeerHandler(peerManager, negotiator, replicationReplicator, roomsScanner, logger)
	newPeerSubscriber := pubsub2.NewNewPeerSubscriber(newPeerPubSub, acceptNewPeerHandler, logger)
	advertiser, err := newAdvertiser(public, config)
	if err != nil {
		cleanup()
		return IntegrationTestsService{}, nil, err
	}
	garbageCollector := badger.NewGarbageCollector(db, logger)
	noTxFeedWantListRepository := notx.NewNoTxFeedWantListRepository(txAdaptersFactoryTransactionProvider, logger)
	service := NewService(application, listener, networkDiscoverer, connectionEstablisher, requestSubscriber, roomAttendantEventSubscriber, newPeerSubscriber, advertiser, messageBuffer, createHistoryStreamHandler, garbageCollector, noTxFeedWantListRepository, noTxBlobWantListRepository)
	banListHasher := adapters.NewBanListHasher()
	integrationTestsService := IntegrationTestsService{
		Service:       service,
		BanListHasher: banListHasher,
	}
	return integrationTestsService, func() {
		cleanup()
	}, nil
}

// wire.go:

type BadgerNoTxTestAdapters struct {
	NoTxTestAdapters    notx.TestAdapters
	TransactionProvider *badger.TestTransactionProvider
	Dependencies        *badger.TestAdaptersDependencies
}

type BadgerTestAdapters struct {
	TransactionProvider *badger.TestTransactionProvider
	Dependencies        *badger.TestAdaptersDependencies
}

type TestCommands struct {
	RoomsAliasRegister        *commands.RoomsAliasRegisterHandler
	RoomsAliasRevoke          *commands.RoomsAliasRevokeHandler
	ProcessRoomAttendantEvent *commands.ProcessRoomAttendantEventHandler
	DisconnectAll             *commands.DisconnectAllHandler
	DownloadFeed              *commands.DownloadFeedHandler
	RedeemInvite              *commands.RedeemInviteHandler
	AcceptTunnelConnect       *commands.AcceptTunnelConnectHandler

	MigrationImportDataFromGoSSB *commands.MigrationHandlerImportDataFromGoSSB

	PeerManager            *mocks2.PeerManagerMock
	Dialer                 *mocks.DialerMock
	FeedWantListRepository *mocks.FeedWantListRepositoryMock
	CurrentTimeProvider    *mocks.CurrentTimeProviderMock
	InviteRedeemer         *mocks.InviteRedeemerMock
	Local                  identity.Public
	PeerInitializer        *mocks.PeerInitializerMock
	GoSSBRepoReader        *mocks.GoSSBRepoReaderMock
	FeedRepository         *mocks.FeedRepositoryMock
	ReceiveLog             *mocks.ReceiveLogRepositoryMock
}

type TestQueries struct {
	Queries app.Queries

	WantedFeedsProvider *queries.WantedFeedsProvider

	FeedRepository         *mocks.FeedRepositoryMock
	MessageRepository      *mocks.MessageRepositoryMock
	ReceiveLogRepository   *mocks.ReceiveLogRepositoryMock
	SocialGraphRepository  *mocks.SocialGraphRepositoryMock
	FeedWantListRepository *mocks.FeedWantListRepositoryMock
	BanListRepository      *mocks.BanListRepositoryMock
	MessagePubSub          *mocks.MessagePubSubMock
	PeerManager            *mocks2.PeerManagerMock
	BlobStorage            *mocks.BlobStorageMock
	Dialer                 *mocks.DialerMock

	LocalIdentity identity.Public
}

type IntegrationTestsService struct {
	Service Service

	BanListHasher badger.BanListHasher
}

func BuildIntegrationTestsService(t *testing.T) (IntegrationTestsService, error) {
	service, cleanup, err := buildIntegrationTestsService(t)
	if err != nil {
		return IntegrationTestsService{}, errors.Wrap(err, "error calling wire builder")
	}
	t.Cleanup(cleanup)
	return service, nil
}

func newAdvertiser(l identity.Public, config Config) (*local.Advertiser, error) {
	return local.NewAdvertiser(l, config.ListenAddress)
}

func newIntegrationTestConfig(t *testing.T) Config {
	dataDirectory := fixtures.Directory(t)
	oldDataDirectory := fixtures.Directory(t)

	cfg := Config{
		DataDirectory:      dataDirectory,
		GoSSBDataDirectory: oldDataDirectory,
		NetworkKey:         fixtures.SomeNetworkKey(),
		MessageHMAC:        fixtures.SomeMessageHMAC(),
	}
	cfg.SetDefaults()
	return cfg
}

func newBadger(system logging.LoggingSystem, logger logging.Logger, config Config) (*badger2.DB, func(), error) {
	badgerDirectory := filepath.Join(config.DataDirectory, "badger")

	options := badger2.DefaultOptions(badgerDirectory)
	options.Logger = badger.NewLogger(system, badger.LoggerLevelWarning)

	if config.ModifyBadgerOptions != nil {
		adapter := NewBadgerOptionsAdapter(&options)
		config.ModifyBadgerOptions(adapter)
	}

	db, err := badger2.Open(options)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to open the database")
	}

	return db, func() {
		if err := db.Close(); err != nil {
			logger.WithError(err).Error("error closing the database")
		}
	}, nil
}

func privateIdentityToPublicIdentity(p identity.Private) identity.Public {
	return p.Public()
}

func newContextLogger(loggingSystem logging.LoggingSystem) logging.Logger {
	return logging.NewContextLogger(loggingSystem, "scuttlego")
}
